# ПОЛНЫЙ РАЗБОР КОДА ЛЕКСИЧЕСКОГО АНАЛИЗАТОРА (ВАРИАНТ 113311)

Здесь расписано всё: от каждой переменной до логики переходов. Читай внимательно, это твоя шпаргалка.

## 1. ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ И ТАБЛИЦЫ

Это фундамент программы. Без них анализатор не знает, что он ищет.

* **`TW` (Table of Words)**: Список всех "зарезервированных" слов. Это команды, которые ты не можешь использовать как имена переменных. Сюда входят `if`, `while`, `read`, `as` и так далее. Если слово в коде совпадает с этим списком — это команда.
* **`TL` (Table of Limiters)**: Список всех спецсимволов. Скобки, плюсы, точки с запятой и даже многосимвольные знаки типа `<>` (не равно) или `/*` (начало коммента).
* **`mTI` (Table of Identifiers)**: Сначала этот список пуст. Сюда программа будет ПИСАТЬ названия твоих переменных. Если программа нашла слово, которого нет в `TW`, она заносит его сюда.
* **`mTN` (Table of Numbers)**: Сюда записываются все числа, которые встретились в коде. Программе проще работать с номером числа в списке, чем с самим числом.

---

## 2. КЛАСС И ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ

Вся логика сидит внутри класса `LexicalAnalyzer`.

### `__init__(self, source_code)`
Это конструктор. Когда ты запускаешь программу, она берет весь твой текст из файла и сохраняет его в `self.source`. 
* `self.pos = 0`: это "курсор". Он показывает, на какой по счету букве в тексте мы сейчас находимся.
* `self.ch = ''`: здесь хранится ОДНА текущая буква, которую мы сейчас изучаем.
* `self.stack = ""`: это временный буфер (строка). Сюда мы по буквам "склеиваем" слово или число.

### `gc(self)` (Get Character)
Самая важная функция. Она берет текущую букву из текста, кладет её в `self.ch` и сдвигает курсор `self.pos` на единицу вперед. Когда буквы в файле кончаются, она выдает символ `\0`.

### `out(self, table_num, index)`
Функция вывода. Когда мы поняли, что за лексема перед нами, мы вызываем `out`. Она берет номер таблицы (1 — слова, 2 — знаки, 3 — числа, 4 — переменные) и порядковый номер в этой таблице. Эти пары чисел и есть результат работы.

---

## 3. ГЛАВНЫЙ ЦИКЛ И СОСТОЯНИЯ (DFA)

Функция `analyze()` — это бесконечный цикл `while True`. Внутри него работает **Конечный Автомат**. Программа всегда находится в каком-то состоянии (`state`).

### Состояние "H" (Начало / Home)
Программа стоит здесь перед каждым новым словом.
1. Пропускает все пробелы (`isspace`).
2. Если видит букву — `state = "I"`. Начинаем собирать имя или команду.
3. Если видит цифру — `state = "N"`. Начинаем собирать число.
4. Если видит `/` — идем проверять, не комментарий ли это (состояние `C1`).
5. Если видит знак `<` или `>` — идем в `M1` или `M2`, чтобы проверить, нет ли там второго знака (типа `<=`).

### Состояние "I" (Identifier / Идентификатор)
Здесь мы крутимся в цикле `while self.ch.isalnum()`. Это значит: "пока идут буквы или цифры — добавляй их в стек".
Как только попалось что-то другое (пробел или скобка):
* Проверяем: есть ли собранная строка в `TW`? 
* Если есть — печатаем `(1, индекс)`.
* Если нет — закидываем в `mTI` (если его там еще нет) и печатаем `(4, индекс)`.

### Состояния чисел (N2, N8, N10)
Автомат смотрит на первую цифру.
* Если это `0` или `1`, мы подозреваем двоичную систему.
* Но если дальше идут цифры до `9`, переключаемся на десятичную.
* Если в конце строки мы встретили букву `H` или `h`, программа понимает: "Ага, это шестнадцатеричное число!" и сохраняет его как одну лексему в таблицу констант.

### Состояния комментариев (C1, C2, C3)
Это механизм игнорирования мусора.
* **C1**: Мы увидели `/`. Если за ним идет `*`, значит это начало комментария — прыгаем в `C2`.
* **C2**: Читаем всё подряд и ничего не записываем. Ищем символ `*`. Как только нашли — идем в `C3`.
* **C3**: Если после `*` сразу идет `/`, значит комментарий кончился. Возвращаемся в начало `H`. Если нет — идем обратно в `C2` и продолжаем игнорировать текст.

### Состояния сравнения (M1, M2)
Нужны для знаков, состоящих из двух символов.
* В `M1` мы попали, увидев `<`. Проверяем следующий символ:
    * Если это `>`, то лексема — `<>` (не равно).
    * Если это `=`, то лексема — `<=` (меньше или равно).
    * Если там что-то другое — значит это просто знак "меньше".

---

## 4. ИТОГ РАБОТЫ

После того как цикл доходит до конца файла (`\0`), программа закрывает файл `input.txt` и создает `output.txt`. 

В `output.txt` будет строка типа: `(2,1) (1,1) (4,1) (2,12)`. 
Это и есть "модельный язык", переведенный в цифровые коды. Каждая пара — это ссылка на одну из четырех таблиц.